<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[一个有趣的java控制台]]></title>
      <url>/2017/06/26/%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84java%E6%8E%A7%E5%88%B6%E5%8F%B0/</url>
      <content type="html"><![CDATA[<p><iframe src="http://www.javarepl.com/embed.html" style="width: 720px; height: 350px; border: 0px"></iframe><br><a href="http://blog.csdn.net/renfufei/article/details/48481439" target="_blank" rel="external">csdn介绍</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[kali+virtualbox调节屏幕分辨率]]></title>
      <url>/2017/06/25/kali-virtualbox%E8%B0%83%E8%8A%82%E5%B1%8F%E5%B9%95%E5%88%86%E8%BE%A8%E7%8E%87/</url>
      <content type="html"><![CDATA[<h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><p>今天安装在virtualbox上安装了kali linux,安装好以后发现屏幕分辨率为1024<em>768,看起来特别小. 于是打开kali中显示器设置,发现只有1024</em>768和更低的分辨率可选.<br><img src="/images/pasted-2.png" alt="upload successful"></p>
<h3 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h3><p>上网搜解决方案,通过<a href="https://docs.kali.org/general-use/kali-linux-virtual-box-guest" target="_blank" rel="external">官方文档</a>了解到需要安装增强工具.照做之后仍然无法调整屏幕分辨率.<br> 于是尝试使用官网上旧的方案安装,按照<a href="http://jingyan.baidu.com/article/73c3ce28e6b899e50343d92f.html" target="_blank" rel="external">百度经验</a><br>尝试安装.报错.被告知先要执行<br><code>apt-get install gcc make linux-headers-$(uname -r)</code><br>执行报错.报错为:<br><code>Unable to locate package &#39;linux-headers-4.9.0-kali3-amd64&#39;</code><br> 然后我在<br><a href="https://unix.stackexchange.com/questions/266871/cannot-find-linux-headers-4-3-0-kali-amd64" target="_blank" rel="external">某个外国论坛</a><br>按照教程更新了内核,重新尝试,仍然报错.<br>继续寻找解决方案.翻遍了互联网,仍然不行.<br>无奈之下考虑版本冲突.原来的virtualbox 版本为5.024 .更新到当前最新的5.1.22后重启虚拟机安装直接成功,重启后分辨率可调节:<br><img src="/images/pasted-4.png" alt="upload successful">  </p>
<h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>官网文档一般不会出错,出错后考虑版本环境问题.<br>还是自己太菜了,此外kali的图标真的帅,甩出ubuntu,红帽,centos20条街.</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 难以解决 </tag>
            
            <tag> kali </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[翻译api哪家强]]></title>
      <url>/2017/06/14/%E7%BF%BB%E8%AF%91api%E5%93%AA%E5%AE%B6%E5%BC%BA/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><span style="color:blue">问题</span></h3><p>今天遇到一个场景.需要将5500个单词从英文转为中文存到数据库中去,同时需要的存储的还有它们的音标.<br>由于数据量并不是很大,写一个循环调用5500次网上的翻译api就好了,但是在选择api上难到了我.  </p>
<h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><p>首先需要说明的是所有的这些翻译网站都可以通过模拟请求来爬出翻译来,但是代码会难一些.所以还是找一些现成的比较方便.最终找到了几个api如下表:<br><img src="/images/pasted-1.png" alt="api对比图">  </p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>有道17年5月的时候更新了一次,以前的api变了.之前的api每到1000次的时候就会被限制,新的使用起来又复杂了一些.百度的返回值没有看见音标.扇贝的不用申请key.但是请求500次之后ip被限制,结合使用场景最终选择了金山词霸.<br>写了个循环读取网站上json的小程序拿到了数据,插入了数据库当中.</p>
]]></content>
      
        
        <tags>
            
            <tag> api </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[华为手机不显示错误日志]]></title>
      <url>/2017/06/14/%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/</url>
      <content type="html"><![CDATA[<p>从某一天开始,我的华为荣耀的logcat 突然不显示app抛出的异常日志.但是如果是写一些像<code>log.e(“error”,”errorInfo”)</code>的代码logcat可以显示.<br>然后我就很少用华为来调试程序了.今天去网上搜了原因,最终找到原因如下:<br><blockquote><p>进入拨号界面输入：<em>#</em>#2846579#<em>#</em><br>依次选择ProjectMenu—后台设置—-LOG设置—LOG开关 点击打开</p>
<footer><strong>解决方案</strong><cite><a href="https://stackoverflow.com/questions/18124334/huawei-logcat-not-showing-the-log-for-my-app" target="_blank" rel="external">链接</a></cite></footer></blockquote><br>  设置完成后并没有起效果,重启后才有效.也许正是某次重启导致了这个问题出现吧.</p>
]]></content>
      
        <categories>
            
            <category> android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[新的一天]]></title>
      <url>/2017/06/11/%E6%96%B0%E7%9A%84%E4%B8%80%E5%A4%A9/</url>
      <content type="html"><![CDATA[<h3 id="又一次开始"><a href="#又一次开始" class="headerlink" title="又一次开始"></a>又一次开始</h3><p>花了几个小时又搭了一个博客,之前也写过一些,但是一直都没有坚持下来.<br>这次选的hexo 用的material主题,因为它看起来很干净.<br>markdown的语法几乎记不起来了.其实只要记得,引用,代码块,图片,列表就够了吧.挨个试一下.  </p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><blockquote><p><item><br>一个字符串，可包括样式设置标记。其值可以是对另一字符串资源的引用。 必须是 <string-array> 元素的子项。请注意，您必须将撇号和引号转义。 如需了解有关如何正确设置字符串样式和格式的信息，请参阅下文的格式和样式设置。<br>无属性。</string-array></item></p>
<footer><strong>android</strong><cite><a href="https://developer.android.com/guide/topics/resources/string-resource.html" target="_blank" rel="external">链接</a></cite></footer></blockquote>  
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args [])</span> </span>&#123;</div><div class="line">	System.out.println(<span class="string">" "</span>);</div><div class="line">&#125;  </div><div class="line">暂时这样有空调出来代码高亮。</div></pre></td></tr></table></figure>  
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><img src="/image/head.jpg" width="300" height="300">
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><ul>
<li>value1</li>
<li>value2 </li>
</ul>
<p>这些就够写博客了。还是希望能坚持下去</p>
]]></content>
      
        <categories>
            
            <category> 胡言乱语 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 没什么用 </tag>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[课程:泛型]]></title>
      <url>/2016/11/11/%E8%AF%BE%E7%A8%8B%EF%BC%9A%E6%B3%9B%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>在任何的软件中，bug都是很常见的。小心的计划，编写然后测试可能减少bug的出现频率。但是从某种程度上来说，bug总会在你的代码中出现。而当你的代码体积增大，项目复杂之后bug变得尤为常见。<br>幸运的是，一些种类的bug可以较为简单的被检查出来。比如说编译时的bug，你可以使用编译器提供的错误信息来找出问题所在然后修复它。<br>然而运行时出现的bug会是一个较为复杂的问题。它们不那么容易被发现。而且当它们出现的时候，错误可能指向一个并不是问题所在的位置。<br>泛型可以使你的某些bug可以在编译时就被发现，这增加了你代码的稳定性。当你完成了本课程，你可能想学习<a href="https://docs.oracle.com/javase/tutorial/extra/generics/index.html" target="_blank" rel="external">Gilad Bracha 关于泛型的课程</a>  </p>
<p>译者注:翻译自<a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html" target="_blank" rel="external">java泛型官方文档</a>,欢迎斧正.<br><a href="../为什么用泛型">下一页</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[受限的类型参数]]></title>
      <url>/2016/11/11/%E5%8F%97%E9%99%90%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>#受限的类型参数<br>有时我们可能想要限制类型参数的可选类型。比如说一个操作Number类的方法可能只想接受Number类型以及他的子类，这就是我们为什么要使用受限类型参数。</p>
<p>为了声明一个受限类型参数，列出类型参数的名字，后边是<strong>extends</strong>关键字，再然后是他的上界，在这个例子中是Number。需要注意的是在这个情境中，Extends既表示继承(对类来说)也表示实现（对接口来说）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Box&lt;T&gt; &#123;</div><div class="line"></div><div class="line">    private T t;          </div><div class="line"></div><div class="line">    public void set(T t) &#123;</div><div class="line">        this.t = t;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public T get() &#123;</div><div class="line">        return t;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public &lt;U extends Number&gt; void inspect(U u)&#123;</div><div class="line">        System.out.println(&quot;T: &quot; + t.getClass().getName());</div><div class="line">        System.out.println(&quot;U: &quot; + u.getClass().getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();</div><div class="line">        integerBox.set(new Integer(10));</div><div class="line">        integerBox.inspect(&quot;some text&quot;); // error: this is still String!</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们的inspect方法使用了受限的类型参数，比较就会失败，因为我们调用inspect方法时使用了String。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Box.java:21: &lt;U&gt;inspect(U) in Box&lt;java.lang.Integer&gt; cannot</div><div class="line">  be applied to (java.lang.String)</div><div class="line">                        integerBox.inspect(&quot;10&quot;);</div><div class="line">                                  ^</div><div class="line">1 error</div></pre></td></tr></table></figure></p>
<p>除了以上的功能，受限类型参数允许你调用提供限制类的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class NaturalNumber&lt;T extends Integer&gt; &#123;</div><div class="line"></div><div class="line">    private T n;</div><div class="line"></div><div class="line">    public NaturalNumber(T n)  &#123; this.n = n; &#125;</div><div class="line"></div><div class="line">    public boolean isEven() &#123;</div><div class="line">        return n.intValue() % 2 == 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>isEven方法调用了Integer类的intValue方法。</p>
<p>###多个受限参数<br>上面的例子阐述了类型参数的单个限制，但是一个类型参数可以有多个限制条件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;T extends B1 &amp; B2 &amp; B3&gt;</div></pre></td></tr></table></figure></p>
<p>一个有多个限定的类型参数的声明如上所示。这个参数必须继承或实现所有的限制类或接口。需要注意的是限制类必须第一个声明。举例来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Class A &#123; /* ... */ &#125;</div><div class="line">interface B &#123; /* ... */ &#125;</div><div class="line">interface C &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">class D &lt;T extends A &amp; B &amp; C&gt; &#123; /* ... */ &#125;</div></pre></td></tr></table></figure></p>
<p>如果不这样做，我们就会得到编译错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class D &lt;T extends B &amp; A &amp; C&gt; &#123; /* ... */ &#125;  // compile-time error</div></pre></td></tr></table></figure></p>
<p><a href="../泛型方法和受限类型参数">下一页</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[无界通配符]]></title>
      <url>/2016/11/11/%E6%97%A0%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
      <content type="html"><![CDATA[<p>#无界通配符<br>无界通配符是指通配符(?)，比如List&lt;?&gt;，它被称为未知类型list。无界通配符适用于在以下两种情况：</p>
<ol>
<li>如果你要实现的是一个适用于Object作为类型参数的方法。</li>
<li>调用那些无关于类型参数的方法时，比如List.size或List.clear。实际上Class&lt;?&gt;被频繁的使用因为Class<t>的大部分方法和T无关。<br>考虑<code>printList</code>方法如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void printList(List&lt;Object&gt; list) &#123;</div><div class="line">    for (Object elem : list)</div><div class="line">        System.out.println(elem + &quot; &quot;);</div><div class="line">    System.out.println();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</t></li>
</ol>
<p>以上方法的目标是打印任何类型的list，但是它并没有完成它的目标-它只能输出List<object>,不能打印 List<integer>, List<string>, List<double>···，因为他们不是List<object>的子类型，我们应该使用List&lt;?&gt;.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void printList(List&lt;?&gt; list) &#123;</div><div class="line">    for (Object elem: list)</div><div class="line">        System.out.print(elem + &quot; &quot;);</div><div class="line">    System.out.println();</div><div class="line">&#125;</div></pre></td></tr></table></figure></object></double></string></integer></object></p>
<p>对于任何确定的类型A,<code>List&lt;A&gt;</code>都是<code>List&lt;?&gt;</code>的子类型，所以我们可以使用print方法来输出任何类型的List<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; li = Arrays.asList(1, 2, 3);</div><div class="line">List&lt;String&gt;  ls = Arrays.asList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);</div><div class="line">printList(li);</div><div class="line">printList(ls);</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：Arrays.asList方法是一个静态的工厂方法，它把给定的Array转化成大小合适的list。</p>
<p>此外，<code>List&lt;Object&gt;</code>和List&lt;?&gt;是不同的，我们可以<code>List&lt;Object&gt;</code>中插入任何Obejct和Object的子类型，但是我们只能在List&lt;?&gt;中插入null。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[上界通配符]]></title>
      <url>/2016/11/11/%E4%B8%8A%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
      <content type="html"><![CDATA[<p>###上界通配符<br>我们可以使用上界通配符来放松对变量的限制。举例来说，如果你想写一个适用在<code>List&lt;Integer&gt;, List&lt;Double&gt;, 和 List&lt;Number&gt;</code>上的方法，你可以通过上界通配符来实现。<br>为了声明一个上界通配符，使用通配符‘？’，然后是<strong>extends</strong>关键字。再然后是上界。注意在此extends既指继承也指实现。<br><code>List&lt;? extends Number&gt;</code>可以适用于<code>List&lt;Integer&gt;, List&lt;Double&gt;</code>,<code>但是List&lt;Number&gt;</code>只适用于<code>但是List&lt;Number&gt;</code>。<br>考虑process方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static void process(List&lt;? extends Foo&gt; list) &#123; /* ... */ &#125;</div></pre></td></tr></table></figure></p>
<p>上界通配符<code>&lt;? extends Foo&gt;</code>适用于Foo和Foo的所有子类。process方法可以访问关于Foo的list<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void process(List&lt;? extends Foo&gt; list) &#123;</div><div class="line">    for (Foo elem : list) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>sumOfList方法返回list中所有元素的和：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static double sumOfList(List&lt;? extends Number&gt; list) &#123;</div><div class="line">    double s = 0.0;</div><div class="line">    for (Number n : list)</div><div class="line">        s += n.doubleValue();</div><div class="line">    return s;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以下代码使用一个Integer的list，会输出<code>sum=6.0</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; li = Arrays.asList(1, 2, 3);</div><div class="line">System.out.println(&quot;sum = &quot; + sumOfList(li));</div></pre></td></tr></table></figure></p>
<p>同样也可以使用double，以下的代码输出<code>sum=7.0</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;Double&gt; ld = Arrays.asList(1.2, 2.3, 3.5);</div><div class="line">System.out.println(&quot;sum = &quot; + sumOfList(ld));</div></pre></td></tr></table></figure></p>
<p><a href="../无界通配符">下一页</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[泛型,继承和子类型]]></title>
      <url>/2016/11/11/%E6%B3%9B%E5%9E%8B,%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AD%90%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>正如你所知，如果一个类型适配另一个类型，那么我们可以用这个类型的对象给另一个类型的对象赋值，举例来说，因为Object是Integer的父类我们可以给一个Object对象一个Integer的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Object someObject = new Object();</div><div class="line">Integer someInteger = new Integer(10);</div><div class="line">someObject = someInteger;   // OK</div></pre></td></tr></table></figure></p>
<p>在面向对象的术语中，这叫做“是一个”的关系。既然Integer是一个Obejct，这个赋值就是被允许的。而且既然Integer是一个Number,所以以下代码也是正确的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void someMethod(Number n) &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">someMethod(new Integer(10));   // OK</div><div class="line">someMethod(new Double(10.1));   // OK</div></pre></td></tr></table></figure></p>
<p>这一点在泛型上也适用，声明一个泛型调用，以Number作为它的类型参数。这样如果使用适配Number的类型都可以作为类型参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Box&lt;Number&gt; box = new Box&lt;Number&gt;();</div><div class="line">box.add(new Integer(10));   // OK</div><div class="line">box.add(new Double(10.1));  // OK</div></pre></td></tr></table></figure></p>
<p>现在我们考虑如下方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void boxTest(Box&lt;Number&gt; n) &#123; /* ... */ &#125;</div></pre></td></tr></table></figure></p>
<p>它可以接收什么样的参数？通过方法声明，我们可以看出它只接受一个Box<number>类型的参数，但是这意味着什么？是否和你期望的一样它可以接受Box<integer>或是Box<double>?答案是不行，因为Box<integer>不是Box<number>的子类型。<br>这在泛型编程中可能有些难理解，但是这是泛型编程的一个重点<br><img src="https://docs.oracle.com/javase/tutorial/figures/java/generics-subtypeRelationship.gif" alt=""><br>虽然Integer是Number的子类，但是<code>Box&lt;Integer&gt;</code>并不是<code>Box&lt;Number&gt;</code>的子类。</number></integer></double></integer></number></p>
<p>需要注意：假设有A,B两个类,不管A,B是什么关系，<code>MyClass&lt;A&gt;</code>和<code>MyClass&lt;B&gt;</code>都没有任何关系，<code>MyClass&lt;A&gt;</code>,<code>MyClass&lt;B&gt;</code>的共同父类是Object。<br>如果你想了解如何创建泛型间的父子关系，请参考<a href="https://docs.oracle.com/javase/tutorial/java/generics/subtyping.html" target="_blank" rel="external">通配符和子类型</a>。</p>
<p>###泛型类和子类型<br>我们可以通过继承或实现一个泛型类来创建它的子类型，两者的关系依赖于你是继承还是实现它。<br>以Collections类为例，<code>ArrayList&lt;E&gt;</code>实现了<code>List&lt;E&gt;</code>,<code>List&lt;E&gt;</code>继承了<code>Collection&lt;E&gt;</code>,所以说<code>ArrayList&lt;String&gt;</code>是<code>List&lt;String&gt;</code>的子类型。既然我们没有变类型参数。所以他们之间的关系如下图所示：<br><img src="https://docs.oracle.com/javase/tutorial/figures/java/generics-sampleHierarchy.gif" alt=""><br>假设我们现在想定义哦我们呢自己的list接口PayLoadList,它有一个可变的类型参数P,它的声明可能像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">interface PayloadList&lt;E,P&gt; extends List&lt;E&gt; &#123;</div><div class="line">  void setPayload(int index, P val);</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以下的类都是<code>List&lt;String&gt;</code>类的子类。</p>
<ul>
<li><code>PayloadList&lt;String,String&gt;</code></li>
<li><code>PayloadList&lt;String,Integer&gt;</code></li>
<li><code>PayloadList&lt;String,Exception&gt;</code><br><img src="https://docs.oracle.com/javase/tutorial/figures/java/generics-payloadListHierarchy.gif" alt=""><br><a href="../类型推理">下一页</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[原生类型]]></title>
      <url>/2016/11/11/%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>#原生类型<br>原生类型是指那些不带类型参数的泛型类或接口。举例来说，对于泛型类Box:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public class Box&lt;T&gt; &#123;</div><div class="line">    public void set(T t) &#123; /* ... */ &#125;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了创建参数化的Box<t>类，我们需要提供一个类型参数给T,:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Box&lt;Integer&gt; intBox=new Box&lt;&gt;();</div></pre></td></tr></table></figure></t></p>
<p>如果实际的类型参数被隐藏起来，你可以创建一个原生类型的Box<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Box rawBox = new Box();</div></pre></td></tr></table></figure></p>
<p>因此Box是<code>Box&lt;T&gt;</code>的原生版，然而一个非泛型类或接口不是原生类型。</p>
<p>原生类型一般在遗留代码中出现，因为很多API的类（比如说Collections）在JDK5.0之前不是泛型。我们大体上可以使用之前的特性。比如使用一个Object给Box赋值。为了代码兼容性，将泛型版本的对象赋值给原生版本是可以的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Box&lt;String&gt; stringBox = new Box&lt;&gt;();</div><div class="line">Box rawBox = stringBox;               // OK</div></pre></td></tr></table></figure></p>
<p>但是如果反过来就会有警告出现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Box rawBox = new Box();           // rawBox is a raw type of Box&lt;T&gt;</div><div class="line">Box&lt;Integer&gt; intBox = rawBox;     // warning: unchecked conversion</div></pre></td></tr></table></figure></p>
<p>如果原生类型调用泛型方法一样会产生警告<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Box&lt;String&gt; stringBox = new Box&lt;&gt;();</div><div class="line">Box rawBox = stringBox;</div><div class="line">rawBox.set(8);  // warning: unchecked invocation to set(T)</div></pre></td></tr></table></figure></p>
<p>这个警告的出现是因为原生类型没有经过类型的检查，将不安全代码的检查推迟到了软件运行时。因此，我们应该避免使用原生类型。</p>
<p>类型删除部分有更多关于java编译器如何使用原生类型的信息。</p>
<p>###’未检查错误’信息<br>正如之前所说的那样，当遗留代码和泛型代码混用的时候，你也许会遇到下面这样的警告信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Note: Example.java uses unchecked or unsafe operations.</div><div class="line">Note: Recompile with -Xlint:unchecked for details.</div></pre></td></tr></table></figure></p>
<p>当旧的API操作原生类型的时，可能会出现这种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class WarningDemo &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Box&lt;Integer&gt; bi;</div><div class="line">        bi = createBox();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static Box createBox()&#123;</div><div class="line">        return new Box();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>“unchecked”表示编译器没有足够的信息进行类型检查来保证类型的安全。默认情况下这个警告是被禁用的。如果你想看到这个警告，请在编译时加上 -Xlint:unchecked选项。<br>加上这个选项后重新编译我们的得到如下的编译信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">WarningDemo.java:4: warning: [unchecked] unchecked conversion</div><div class="line">found   : Box</div><div class="line">required: Box&lt;java.lang.Integer&gt;</div><div class="line">        bi = createBox();</div><div class="line">                      ^</div><div class="line">1 warning</div></pre></td></tr></table></figure></p>
<p>为了彻底禁用未检查警告，使用’-Xlint:-unchecked’选项。注解<code> @SuppressWarnings(“unchecked”)</code>抑制了未检查警告。<br><a href="../泛型方法">下一页</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[泛型方法和受限类型参数]]></title>
      <url>/2016/11/11/%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E5%92%8C%E5%8F%97%E9%99%90%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>#泛型方法和受限类型参数<br>受限类型参数是实现泛型方法的关键所在。下面的方法是统计T数组中超过elem的元素个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static &lt;T&gt; int countGreaterThan(T[] anArray, T elem) &#123;</div><div class="line">    int count = 0;</div><div class="line">    for (T e : anArray)</div><div class="line">        if (e &gt; elem)  // compiler error</div><div class="line">            ++count;</div><div class="line">    return count;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法的实现是很简单的，但是我们会得到一个编译错误，因为&gt;符号只能用在基本类型上。为了修正这个错误，使用一个受限于Comparable<t>接口的类型参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Comparable&lt;T&gt; &#123;</div><div class="line">    public int compareTo(T o);</div><div class="line">&#125;</div></pre></td></tr></table></figure></t></p>
<p>最终的代码会如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static &lt;T extends Comparable&lt;T&gt;&gt; int countGreaterThan(T[] anArray, T elem) &#123;</div><div class="line">    int count = 0;</div><div class="line">    for (T e : anArray)</div><div class="line">        if (e.compareTo(elem) &gt; 0)</div><div class="line">            ++count;</div><div class="line">    return count;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="../泛型,继承和子类型">下一页</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[泛型类型]]></title>
      <url>/2016/11/11/%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>#泛型类型<br>泛型类型是一个参数化的普通的类或者接口。以下我们通过修改<strong>Box</strong>类来说明这点。</p>
<p>###一个简单的Box类<br>我们从一个非泛型的Box类开始。Box类可以操作任何任何类型的对象。它只需要提供两个方法，<strong>set</strong>用来向Box中增加一个对象和<strong>get</strong>用来检索这个对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Box &#123;</div><div class="line">    private Object object;</div><div class="line"></div><div class="line">    public void set(Object object) &#123; this.object = object; &#125;</div><div class="line">    public Object get() &#123; return object; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>既然Box的方法接受或者返回的都是Object。那么你可以传递任何非原生类型的参数。我们在编译时没有办法确定这个类是如何被使用的。一部分代码可能在这个类中放入一个Integer,并且期望取出一个Integer,但是另一部分代码可能错误的将取出的Integer转为String,结果就是出现了运行时异常。</p>
<p>###Box类的泛型版本<br>一个泛型类可以通过如下的形式定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class name&lt;T1, T2, ..., Tn&gt; &#123; /* ... */ &#125;</div></pre></td></tr></table></figure></p>
<p>类名后边被尖括号括起来的部分就是类型参数。它声明了类型参数T1,T2…Tn.</p>
<p>为了使Box类使用泛型，我们可以通过改变类声明为“public class Box<t>”来创建一个泛型类型声明。这就声明了类型变量<strong>T</strong>,它可以被用在Box类的各个部分。</t></p>
<p>经过这些变化，Box类变成了下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Generic version of the Box class.</div><div class="line"> * @param &lt;T&gt; the type of the value being boxed</div><div class="line"> */</div><div class="line">public class Box&lt;T&gt; &#123;</div><div class="line">    // T stands for &quot;Type&quot;</div><div class="line">    private T t;</div><div class="line"></div><div class="line">    public void set(T t) &#123; this.t = t; &#125;</div><div class="line">    public T get() &#123; return t; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如你所见，所有Object都被替换成了T,一个类型参数可以是任何非原生的类型，包括类，接口，或是数组甚至是其他的类型变量。<br>和以上相同的技术也可以被用来创建泛型接口。</p>
<p>###类型参数命名习惯<br>一般来说，类型参数的名字是单个大写字母，这和变量的命名形成了鲜明的对比。这么做的原因是：如果不这样，区分类型变量和普通类的名字将会十分复杂。<br>最常用类型参数名字如下所示：</p>
<ul>
<li>E Element</li>
<li>K Key</li>
<li>N number</li>
<li>T Type</li>
<li>V value</li>
<li>S,U,V etc 第二三四…个类型。</li>
</ul>
<p>这些名字被广泛使用在Java SE API和课程的其他部分中。</p>
<p>###调用和实例化一个泛型类型<br>想要得到一个Box类的引用，你必须进行泛型类型的调用，在调用中你需要将T替换成一些确定的值如Integer。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Box&lt;Integer&gt; integerBox;</div></pre></td></tr></table></figure></p>
<p>你可以将泛型类型调用和普通的参数调用类比，但是不同于提供一个变量给这个方法，你传递了一个<strong>类型变量</strong>给了Box 类。</p>
<p>类型参数和类型变量：很多开发者将这两个概念互换，然而他们并不相同。Foo<t>中的T是类型参数，而Foo<string>中的String是类型变量。</string></t></p>
<p>像其他变量声明一样，以上的代码并没有创建一个新的Box对象，他只是声明了integerBox将存放一个‘存放Integer的Box’的引用。这就是Box<integer>的含义。<br>一个泛型类型的调用一般被称作参数化类型。</integer></p>
<p>要实例化这个类，使用new关键字。但是我们需要把<integer>放在类名和括号之间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();</div></pre></td></tr></table></figure></integer></p>
<p>TIPS:从java7开始，我们可以这样写了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Box&lt;Integer&gt; integerBox = new Box&lt;&gt;();</div></pre></td></tr></table></figure></p>
<p>###多类型参数<br>正如之前提及的那样，一个泛型类可以有多个类型参数。举个例子：OrderedPair类，它实现了Pair接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public interface Pair&lt;K, V&gt; &#123;</div><div class="line">    public K getKey();</div><div class="line">    public V getValue();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class OrderedPair&lt;K, V&gt; implements Pair&lt;K, V&gt; &#123;</div><div class="line"></div><div class="line">    private K key;</div><div class="line">    private V value;</div><div class="line"></div><div class="line">    public OrderedPair(K key, V value) &#123;</div><div class="line">	this.key = key;</div><div class="line">	this.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public K getKey()	&#123; return key; &#125;</div><div class="line">    public V getValue() &#123; return value; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以下的代码创建了两个OrderedPair类的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String, Integer&gt; p1 = new OrderedPair&lt;String, Integer&gt;(&quot;Even&quot;, 8);</div><div class="line">Pair&lt;String, String&gt;  p2 = new OrderedPair&lt;String, String&gt;(&quot;hello&quot;, &quot;world&quot;);</div></pre></td></tr></table></figure></p>
<p>代码<code>new OrderedPair &lt; String, Integer &gt;</code>将K实例化为String,V实例化为Integer。因此，OrderedPair的构造函数的参数类型为String,和Integer。此外，因为自动装箱技术。我们可以传入int作为参数。</p>
<p>另外根据tips,我们可以写作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OrderedPair&lt;String, Integer&gt; p1 = new OrderedPair&lt;&gt;(&quot;Even&quot;, 8);</div></pre></td></tr></table></figure></p>
<p>创建泛型接口和创建泛型类的方法相同。</p>
<p>###泛型参数作为参数类型<br>你也可以将类型参数替换为泛型类。以OrderedPair<k, v=""> 为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OrderedPair&lt;String, Box&lt;Integer&gt;&gt; p = new OrderedPair&lt;&gt;(&quot;primes&quot;, new Box&lt;Integer&gt;(...));</div></pre></td></tr></table></figure></k,></p>
<p><a href="../原生类型">下一页</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[类型推理]]></title>
      <url>/2016/11/11/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E7%90%86/</url>
      <content type="html"><![CDATA[<p>#类型推理<br>java编译器可以从方法的调用和该方法的声明来决定类型参数的类型，从而使调用变的有效，这叫做<em>类型推理</em>。推理算法决定了参数类型或是返回类型，最终推理算法尝试寻找最明确的可以应用与所有参数的类型。<br>为了阐明上述内容，举例如下，推理决定了pick方法的第二个参数是Serializable。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">static &lt;T&gt; T pick(T a1, T a2) &#123; return a2; &#125;</div><div class="line">Serializable s = pick(&quot;d&quot;, new ArrayList&lt;String&gt;());</div></pre></td></tr></table></figure></p>
<p>###类型推理和泛型方法<br>在泛型方法这一节中我们介绍过类型推理，它可以使我们像调用普通方法一样调用泛型方法。举例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class BoxDemo &#123;</div><div class="line"></div><div class="line">  public static &lt;U&gt; void addBox(U u, java.util.List&lt;Box&lt;U&gt;&gt; boxes) &#123;</div><div class="line">    Box&lt;U&gt; box = new Box&lt;&gt;();</div><div class="line">    box.set(u);</div><div class="line">    boxes.add(box);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static &lt;U&gt; void outputBoxes(java.util.List&lt;Box&lt;U&gt;&gt; boxes) &#123;</div><div class="line">    int counter = 0;</div><div class="line">    for (Box&lt;U&gt; box: boxes) &#123;</div><div class="line">      U boxContents = box.get();</div><div class="line">      System.out.println(&quot;Box #&quot; + counter + &quot; contains [&quot; +</div><div class="line">             boxContents.toString() + &quot;]&quot;);</div><div class="line">      counter++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static void main(String[] args) &#123;</div><div class="line">    java.util.ArrayList&lt;Box&lt;Integer&gt;&gt; listOfIntegerBoxes =</div><div class="line">      new java.util.ArrayList&lt;&gt;();</div><div class="line">    BoxDemo.&lt;Integer&gt;addBox(Integer.valueOf(10), listOfIntegerBoxes);</div><div class="line">    BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);</div><div class="line">    BoxDemo.addBox(Integer.valueOf(30), listOfIntegerBoxes);</div><div class="line">    BoxDemo.outputBoxes(listOfIntegerBoxes);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行程序结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Box #0 contains [10]</div><div class="line">Box #1 contains [20]</div><div class="line">Box #2 contains [30]</div></pre></td></tr></table></figure></p>
<p>泛型方法addBox定义了一个名为U的类型参数，一般来说，Java编译器可以推理出泛型方法调用的类型参数，因此大部分情况下，我们并不需要显式的指出参数类型。举例来说，如果我们需要调用addBox,我们可以显式的标明参数如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BoxDemo.&lt;Integer&gt;addBox(Integer.valueOf(10), listOfIntegerBoxes);</div></pre></td></tr></table></figure></p>
<p>或者我们可以省略类型声明，Java编译器会推理出类型参数是一个Integer。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);</div></pre></td></tr></table></figure></p>
<p>###类型推理和泛型类实例化<br>既然java编译器可以从上下文中推理出类型参数，我们可以将泛型类构造函数中的类型参数替换为<code>&lt;&gt;</code>,<code>&lt;&gt;</code>被称为<em>the diamond</em>(菱形)。<br>举例来说，考虑如下变量声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap&lt;String, List&lt;String&gt;&gt;();</div></pre></td></tr></table></figure></p>
<p>我们可以声明如下，效果相同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap&lt;&gt;();</div></pre></td></tr></table></figure>
<p>需要注意的是一定要带上<code>&lt;&gt;</code>否则我们会得到一个警告，因为HashMap()构造函数引用的是HashMap的原生类型，而不是<code>Map&lt;String, List&lt;String&gt;&gt;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap(); // unchecked conversion warning</div></pre></td></tr></table></figure></p>
<p>###类型推理，泛型构造函数和非泛型类<br>需要注意无论一个类是不是泛型的，它的构造函数都可以是泛型的，考虑如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class MyClass&lt;X&gt; &#123;</div><div class="line">  &lt;T&gt; MyClass(T t) &#123;</div><div class="line">    // ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们实例化该类如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new MyClass&lt;Integer&gt;(&quot;&quot;)</div></pre></td></tr></table></figure></p>
<p>以上代码创建了一个<code>MyClass&lt;Integer&gt;</code>类型的类，它显式的声明了Integer作为X,隐式的声明了String作为T.<br>从java7我们可以声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MyClass&lt;Integer&gt; myObject = new MyClass&lt;&gt;(&quot;&quot;);</div></pre></td></tr></table></figure></p>
<p>需要注意的是，推理算法只能从调用参数，目标类型，期望的返回值中推理类型，推理算法并不能使用该代码以后的代码来推理参数类型。</p>
<p>###目标类型<br>java编译器可以通过目标类型来推理出参数类型，表达式的目标类型是指java编译器根据表达式的位置来决定的，考虑Colections.emptyList方法，它的声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static &lt;T&gt; List&lt;T&gt; emptyList();</div></pre></td></tr></table></figure></p>
<p>有如下赋值表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; listOne = Collections.emptyList();</div></pre></td></tr></table></figure></p>
<p>以上的表达式期望一个<code>List&lt;String&gt;</code>实例，这就是<em>目标类型</em>。因为emptyList返回一个<code>List&lt;T&gt;</code>,编译器推断T一定是String，这在java7以后都是可用的。<br>但在某些情况下省略是不行的，考虑如下方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void processStringList(List&lt;String&gt; stringList) &#123;</div><div class="line">    // process stringList</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们在java7中这样调用：<br><code>processStringList(Collections.emptyList());</code></p>
<p>我们就会得到错误信息：<code>List&lt;Object&gt; cannot be converted to List&lt;String&gt;</code><br>编译器需要赋给T一个值，所以它从Object开始尝试，因此Collections.emptyList返回一个List<object>对象，这和processStringList不符。因此在java7中你必须这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">processStringList(Collections.&lt;String&gt;emptyList());</div></pre></td></tr></table></figure></object></p>
<p>但是在java8中，目标类型被扩展为包括函数参数，所以写成下面这样也可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">processStringList(Collections.emptyList());</div></pre></td></tr></table></figure></p>
<p><a href="../通配符">下一页</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为什么用泛型？]]></title>
      <url>/2016/11/11/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E6%B3%9B%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>#为什么用泛型？<br>一言以蔽之，当你定义类，接口，方法的时候泛型可以使类型（类和接口）作为参数。和声明方法时那些普通的参数相似，类型参数可以使你针对于不同的输入复用代码。但是和普通参数不同的是普通参数的输入是值，而类型参数的输入是类型。</p>
<p>使用参数的代码拥有更多的好处：</p>
<ul>
<li>更强的编译时类型检查<br>Java 编译器针对泛型使用强类型检查。如果代码中有类型错误更容易被发现。修复编译时错误比运行时错误容易得多。因为运行时错误更不容易被发现。</li>
<li><p>消除类型转换<br>   以下的代码片段需要类型转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List list = new ArrayList();  </div><div class="line">list.add(&quot;hello&quot;);  </div><div class="line">String s = (String) list.get(0);</div></pre></td></tr></table></figure>
<p>  当我们使用泛型重写这段代码之后，代码就不需要类型转换了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">list.add(&quot;hello&quot;);</div><div class="line">String s = list.get(0);   // no cast</div></pre></td></tr></table></figure>
</li>
<li><p>使编程人员可以实现泛型算法。<br>通过使用泛型，编程人员可以实现泛型算法，这些算法可以应用于那些存放不同类型的集合中，这些算法可以被定制，而且具有类型安全和更好的可读性。<br><a href="../泛型类型">下一页</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[通配符]]></title>
      <url>/2016/11/11/%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
      <content type="html"><![CDATA[<p>#通配符<br>在泛型编程中，问号(?)被称作通配符。表示未知的类型。它可以被用在很多情景中，作为参数类型，局部变量，偶尔在返回类型也用它（尽管类型明确些会更好），通配符不鞥用在泛型方法调用时的类型参数或是泛型类的创建中。<br>以下的章节我们将详细讨论通配符的上界，下界和通配符的捕获。<br><a href="../上界通配符">下一页</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[泛型方法]]></title>
      <url>/2016/11/11/%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>#泛型方法<br>泛型方法是声明了它自己的类型参数的方法，这和声明泛型类型有些相似。但是类型参数仅仅被限制在这个声明的方法中。静态或是非静态的都可以，泛型类的构造函数也是这样。<br>泛型方法包括一个在尖括号内，位置是返回类型之前的类型参数。对于静态泛型方法，类型参数必须是在方法返回类型之前。<br>Util类包含一个比较两个Pair对象的泛型方法compare，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Util &#123;</div><div class="line">    public static &lt;K, V&gt; boolean compare(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2) &#123;</div><div class="line">        return p1.getKey().equals(p2.getKey()) &amp;&amp;</div><div class="line">               p1.getValue().equals(p2.getValue());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Pair&lt;K, V&gt; &#123;</div><div class="line"></div><div class="line">    private K key;</div><div class="line">    private V value;</div><div class="line"></div><div class="line">    public Pair(K key, V value) &#123;</div><div class="line">        this.key = key;</div><div class="line">        this.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setKey(K key) &#123; this.key = key; &#125;</div><div class="line">    public void setValue(V value) &#123; this.value = value; &#125;</div><div class="line">    public K getKey()   &#123; return key; &#125;</div><div class="line">    public V getValue() &#123; return value; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以通过如下方式调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Pair&lt;Integer, String&gt; p1 = new Pair&lt;&gt;(1, &quot;apple&quot;);</div><div class="line">Pair&lt;Integer, String&gt; p2 = new Pair&lt;&gt;(2, &quot;pear&quot;);</div><div class="line">boolean same = Util.&lt;Integer, String&gt;compare(p1, p2);</div></pre></td></tr></table></figure></p>
<p>在上面的代码中类型被显式的声明了，事实上调用方法时类型参数可以不写出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Pair&lt;Integer, String&gt; p1 = new Pair&lt;&gt;(1, &quot;apple&quot;);</div><div class="line">Pair&lt;Integer, String&gt; p2 = new Pair&lt;&gt;(2, &quot;pear&quot;);</div><div class="line">boolean same = Util.compare(p1, p2);</div></pre></td></tr></table></figure></p>
<p>这个特性被称为类型推理。允许你以调用普通方法的方式来调用泛型方法，关于更多的细节我们将会在类型推理<a href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html" target="_blank" rel="external">类型推理</a>中说明。<br><a href="../受限的类型参数">下一页</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于]]></title>
      <url>/%E5%85%B3%E4%BA%8E/index.html</url>
      <content type="html"><![CDATA[<p>贾康的个人博客.<br>可以从上边找到一些java,安卓,信息安全,算法的分享<br>评论插件被墙,暂未找到好的替代方案.<br>之所以选用hexo,是如果用动态的,就得用自己的服务器,就得备案.</p>
]]></content>
    </entry>
    
  
</search>
